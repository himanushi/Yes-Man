{
  "name": "Yes-Man Timer Tool",
  "description": "Yes-ManéŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆç”¨ã‚¿ã‚¤ãƒãƒ¼ãƒ„ãƒ¼ãƒ«",
  "version": "1.0.0",
  "author": "Yes-Man Project",
  "tool_type": "timer",
  "nodes": [
    {
      "id": "timer_input",
      "type": "TextInput",
      "position": { "x": 100, "y": 200 },
      "data": {
        "input_text": "",
        "input_name": "duration",
        "input_description": "ã‚¿ã‚¤ãƒãƒ¼ã®ç§’æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ1-3600ç§’ï¼‰"
      }
    },
    {
      "id": "duration_parser",
      "type": "PythonREPL",
      "position": { "x": 300, "y": 200 },
      "data": {
        "name": "parser",
        "description": "ã‚¿ã‚¤ãƒãƒ¼æ™‚é–“ã‚’è§£æãƒ»æ­£è¦åŒ–ã—ã¾ã™",
        "code": "import re\nimport json\n\ndef parse_duration(input_text):\n    \"\"\"æ§˜ã€…ãªæ™‚é–“è¡¨ç¾ã‚’ç§’æ•°ã«å¤‰æ›\"\"\"\n    if not input_text:\n        return None, \"æ™‚é–“ã‚’æŒ‡å®šã—ã¦ãã ã•ã„\"\n    \n    text = input_text.strip().lower()\n    \n    # æ•°å€¤ã®ã¿ã®å ´åˆï¼ˆç§’ã¨ã—ã¦æ‰±ã†ï¼‰\n    if text.isdigit():\n        return int(text), None\n    \n    # ç§’ã€åˆ†ã€æ™‚é–“ã‚’å«ã‚€è¡¨ç¾ã®ãƒ‘ã‚¿ãƒ¼ãƒ³\n    patterns = [\n        # ã€Œ30ç§’ã€ã€Œ30sã€\n        (r'(\\d+)\\s*(?:ç§’|sec|s)', lambda m: int(m.group(1))),\n        # ã€Œ5åˆ†ã€ã€Œ5minã€ã€Œ5mã€\n        (r'(\\d+)\\s*(?:åˆ†|min|m)', lambda m: int(m.group(1)) * 60),\n        # ã€Œ1æ™‚é–“ã€ã€Œ1hourã€ã€Œ1hã€\n        (r'(\\d+)\\s*(?:æ™‚é–“|hour|h)', lambda m: int(m.group(1)) * 3600),\n        # ã€Œ3åˆ†30ç§’ã€\n        (r'(\\d+)\\s*(?:åˆ†|min|m)\\s*(\\d+)\\s*(?:ç§’|sec|s)', \n         lambda m: int(m.group(1)) * 60 + int(m.group(2))),\n        # ã€Œ1æ™‚é–“30åˆ†ã€\n        (r'(\\d+)\\s*(?:æ™‚é–“|hour|h)\\s*(\\d+)\\s*(?:åˆ†|min|m)', \n         lambda m: int(m.group(1)) * 3600 + int(m.group(2)) * 60),\n        # ã€Œ1æ™‚é–“30åˆ†45ç§’ã€\n        (r'(\\d+)\\s*(?:æ™‚é–“|hour|h)\\s*(\\d+)\\s*(?:åˆ†|min|m)\\s*(\\d+)\\s*(?:ç§’|sec|s)',\n         lambda m: int(m.group(1)) * 3600 + int(m.group(2)) * 60 + int(m.group(3))),\n        # ã€ŒMM:SSã€å½¢å¼\n        (r'(\\d+):(\\d+)', lambda m: int(m.group(1)) * 60 + int(m.group(2))),\n        # ã€ŒHH:MM:SSã€å½¢å¼\n        (r'(\\d+):(\\d+):(\\d+)', \n         lambda m: int(m.group(1)) * 3600 + int(m.group(2)) * 60 + int(m.group(3))),\n    ]\n    \n    for pattern, converter in patterns:\n        match = re.search(pattern, text)\n        if match:\n            try:\n                seconds = converter(match)\n                return seconds, None\n            except ValueError as e:\n                return None, f\"æ™‚é–“ã®è§£æã§ã‚¨ãƒ©ãƒ¼: {e}\"\n    \n    # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã—ãªã„å ´åˆã€æ•°å€¤æŠ½å‡ºã‚’è©¦è¡Œ\n    numbers = re.findall(r'\\d+', text)\n    if numbers:\n        try:\n            # æœ€åˆã®æ•°å€¤ã‚’ç§’ã¨ã—ã¦æ‰±ã†\n            seconds = int(numbers[0])\n            return seconds, None\n        except ValueError:\n            pass\n    \n    return None, \"æ™‚é–“ã®å½¢å¼ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ\"\n\ndef validate_duration(seconds):\n    \"\"\"ã‚¿ã‚¤ãƒãƒ¼æ™‚é–“ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯\"\"\"\n    if seconds is None:\n        return False, \"æ™‚é–“ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“\"\n    \n    if seconds <= 0:\n        return False, \"ã‚¿ã‚¤ãƒãƒ¼ã¯1ç§’ä»¥ä¸Šã§è¨­å®šã—ã¦ãã ã•ã„\"\n    \n    if seconds > 3600:  # 1æ™‚é–“\n        return False, \"ã‚¿ã‚¤ãƒãƒ¼ã¯1æ™‚é–“ï¼ˆ3600ç§’ï¼‰ä»¥å†…ã§è¨­å®šã—ã¦ãã ã•ã„\"\n    \n    return True, \"OK\"\n\ndef format_duration(seconds):\n    \"\"\"ç§’æ•°ã‚’èª­ã¿ã‚„ã™ã„å½¢å¼ã«å¤‰æ›\"\"\"\n    if seconds < 60:\n        return f\"{seconds}ç§’\"\n    elif seconds < 3600:\n        minutes = seconds // 60\n        remaining_seconds = seconds % 60\n        if remaining_seconds == 0:\n            return f\"{minutes}åˆ†\"\n        else:\n            return f\"{minutes}åˆ†{remaining_seconds}ç§’\"\n    else:\n        hours = seconds // 3600\n        remaining_minutes = (seconds % 3600) // 60\n        remaining_seconds = seconds % 60\n        \n        result = f\"{hours}æ™‚é–“\"\n        if remaining_minutes > 0:\n            result += f\"{remaining_minutes}åˆ†\"\n        if remaining_seconds > 0:\n            result += f\"{remaining_seconds}ç§’\"\n        return result\n\n# ãƒ¡ã‚¤ãƒ³å‡¦ç†\ninput_text = input().strip()\n\n# æ™‚é–“è§£æ\nseconds, parse_error = parse_duration(input_text)\n\nif parse_error:\n    result = {\n        'success': False,\n        'error': parse_error,\n        'input': input_text,\n        'seconds': None,\n        'formatted_duration': None\n    }\nelse:\n    # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³\n    is_valid, validation_error = validate_duration(seconds)\n    \n    if not is_valid:\n        result = {\n            'success': False,\n            'error': validation_error,\n            'input': input_text,\n            'seconds': seconds,\n            'formatted_duration': None\n        }\n    else:\n        result = {\n            'success': True,\n            'error': None,\n            'input': input_text,\n            'seconds': seconds,\n            'formatted_duration': format_duration(seconds)\n        }\n\nprint(json.dumps(result, ensure_ascii=False))"
      }
    },
    {
      "id": "timer_executor",
      "type": "PythonREPL",
      "position": { "x": 500, "y": 200 },
      "data": {
        "name": "executor",
        "description": "ã‚¿ã‚¤ãƒãƒ¼ã‚’å®Ÿè¡Œã—ã¾ã™",
        "code": "import json\nimport threading\nimport time\nfrom datetime import datetime, timedelta\n\n# ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¿ã‚¤ãƒãƒ¼ç®¡ç†\nactive_timers = {}\ntimer_counter = 0\n\ndef create_timer(seconds, formatted_duration):\n    \"\"\"ã‚¿ã‚¤ãƒãƒ¼ä½œæˆã¨é–‹å§‹\"\"\"\n    global timer_counter\n    timer_counter += 1\n    timer_id = f\"timer_{timer_counter}_{int(time.time())}\"\n    \n    start_time = datetime.now()\n    end_time = start_time + timedelta(seconds=seconds)\n    \n    def timer_callback():\n        try:\n            time.sleep(seconds)\n            # ã‚¿ã‚¤ãƒãƒ¼å®Œäº†å‡¦ç†\n            if timer_id in active_timers:\n                active_timers[timer_id]['status'] = 'completed'\n                active_timers[timer_id]['completed_at'] = datetime.now().isoformat()\n                \n                # ã“ã“ã§éŸ³å£°é€šçŸ¥ã‚„UIã¸ã®é€šçŸ¥ã‚’è¡Œã†\n                # ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€IPCã‚„WebSocketçµŒç”±ã§é€šçŸ¥ï¼‰\n                print(f\"ğŸ”” ã‚¿ã‚¤ãƒãƒ¼å®Œäº†é€šçŸ¥: {formatted_duration}ã®ã‚¿ã‚¤ãƒãƒ¼ãŒçµ‚äº†ã—ã¾ã—ãŸï¼\")\n        except Exception as e:\n            if timer_id in active_timers:\n                active_timers[timer_id]['status'] = 'error'\n                active_timers[timer_id]['error'] = str(e)\n    \n    # ã‚¿ã‚¤ãƒãƒ¼æƒ…å ±ã‚’è¨˜éŒ²\n    active_timers[timer_id] = {\n        'id': timer_id,\n        'seconds': seconds,\n        'formatted_duration': formatted_duration,\n        'start_time': start_time.isoformat(),\n        'end_time': end_time.isoformat(),\n        'status': 'running',\n        'created_at': start_time.isoformat()\n    }\n    \n    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã‚¿ã‚¤ãƒãƒ¼å®Ÿè¡Œ\n    timer_thread = threading.Thread(target=timer_callback, daemon=True)\n    timer_thread.start()\n    \n    return timer_id\n\ndef get_active_timers():\n    \"\"\"ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚¤ãƒãƒ¼ä¸€è¦§å–å¾—\"\"\"\n    current_time = datetime.now()\n    \n    for timer_id, timer_info in active_timers.items():\n        if timer_info['status'] == 'running':\n            end_time = datetime.fromisoformat(timer_info['end_time'])\n            if current_time >= end_time:\n                timer_info['status'] = 'completed'\n                timer_info['completed_at'] = current_time.isoformat()\n    \n    return active_timers\n\n# å…¥åŠ›ãƒ‡ãƒ¼ã‚¿è§£æ\ntry:\n    timer_data = json.loads(input())\nexcept:\n    timer_data = {'success': False, 'error': 'å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ'}\n\nif timer_data['success']:\n    seconds = timer_data['seconds']\n    formatted_duration = timer_data['formatted_duration']\n    \n    try:\n        timer_id = create_timer(seconds, formatted_duration)\n        \n        # Yes-Mané¢¨ã®å¿œç­”ç”Ÿæˆ\n        responses = [\n            f\"ã¯ã„ï¼{formatted_duration}ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸï¼æ™‚é–“ã«ãªã£ãŸã‚‰ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ï¼\",\n            f\"ã‚‚ã¡ã‚ã‚“ã§ã™ï¼{formatted_duration}ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼\",\n            f\"ã‚¿ã‚¤ãƒãƒ¼è¨­å®šå®Œäº†ã§ã™ï¼{formatted_duration}å¾Œã«ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã­ï¼\",\n            f\"ã¯ã„ã€{formatted_duration}ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã—ãŸï¼\",\n        ]\n        \n        # æ™‚é–“ã«å¿œã˜ã¦ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ \n        if seconds >= 1800:  # 30åˆ†ä»¥ä¸Š\n            comment = \"ï¼ˆé•·æ™‚é–“ã®ã‚¿ã‚¤ãƒãƒ¼ã§ã™ã­ï¼ãŠç–²ã‚Œæ§˜ã§ã™ï¼‰\"\n        elif seconds >= 300:  # 5åˆ†ä»¥ä¸Š\n            comment = \"ï¼ˆã¡ã‚‡ã†ã©è‰¯ã„æ™‚é–“ã§ã™ã­ï¼ï¼‰\"\n        elif seconds < 60:   # 1åˆ†æœªæº€\n            comment = \"ï¼ˆçŸ­æ™‚é–“ã®ã‚¿ã‚¤ãƒãƒ¼ã§ã™ã­ï¼ï¼‰\"\n        else:\n            comment = \"\"\n        \n        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹é¸æŠï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰\n        response_index = timer_counter % len(responses)\n        final_response = responses[response_index] + comment\n        \n        result = {\n            'success': True,\n            'error': None,\n            'timer_id': timer_id,\n            'seconds': seconds,\n            'formatted_duration': formatted_duration,\n            'response': final_response,\n            'start_time': active_timers[timer_id]['start_time'],\n            'end_time': active_timers[timer_id]['end_time']\n        }\n        \n    except Exception as e:\n        result = {\n            'success': False,\n            'error': f\"ã‚¿ã‚¤ãƒãƒ¼ã®ä½œæˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}\",\n            'timer_id': None,\n            'seconds': seconds,\n            'formatted_duration': formatted_duration,\n            'response': f\"ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ï¼ã‚¿ã‚¤ãƒãƒ¼ã®è¨­å®šã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã§ã‚‚ã€ã‚‚ã†ä¸€åº¦è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã­ï¼\"\n        }\n        \nelse:\n    # ãƒ‘ãƒ¼ã‚¹ãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼\n    error_msg = timer_data.get('error', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')\n    result = {\n        'success': False,\n        'error': error_msg,\n        'timer_id': None,\n        'response': f\"ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ï¼{error_msg}ã§ã™ã€‚'30ç§’'ã‚„'5åˆ†'ã®ã‚ˆã†ã«æŒ‡å®šã—ã¦ãã ã•ã„ã­ï¼\"\n    }\n\nprint(json.dumps(result, ensure_ascii=False))"
      }
    },
    {
      "id": "timer_status",
      "type": "PythonREPL",
      "position": { "x": 700, "y": 100 },
      "data": {
        "name": "status_checker",
        "description": "ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ç¢ºèªæ©Ÿèƒ½",
        "code": "import json\nfrom datetime import datetime\n\n# ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒãƒ¼ã®çŠ¶æ…‹ç¢ºèª\ndef check_timer_status():\n    \"\"\"ç¾åœ¨ã®ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯\"\"\"\n    try:\n        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã‚„æ°¸ç¶šåŒ–ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—\n        # ã“ã“ã§ã¯ç°¡æ˜“å®Ÿè£…\n        current_time = datetime.now()\n        \n        # ä»®æƒ³çš„ãªã‚¿ã‚¤ãƒãƒ¼æƒ…å ±ï¼ˆå®Ÿéš›ã¯active_timersã‹ã‚‰å–å¾—ï¼‰\n        status_info = {\n            'active_timers_count': len(globals().get('active_timers', {})),\n            'current_time': current_time.isoformat(),\n            'status': 'ready'\n        }\n        \n        if status_info['active_timers_count'] > 0:\n            response = f\"ã¯ã„ï¼ç¾åœ¨ {status_info['active_timers_count']} å€‹ã®ã‚¿ã‚¤ãƒãƒ¼ãŒå‹•ã„ã¦ã„ã¾ã™ï¼\"\n        else:\n            response = \"ã¯ã„ï¼ç¾åœ¨å‹•ã„ã¦ã„ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚æ–°ã—ã„ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®šã—ã¾ã™ã‹ï¼Ÿ\"\n        \n        return {\n            'success': True,\n            'info': status_info,\n            'response': response\n        }\n        \n    except Exception as e:\n        return {\n            'success': False,\n            'error': str(e),\n            'response': \"ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ï¼ã‚¿ã‚¤ãƒãƒ¼ã®çŠ¶æ…‹ç¢ºèªã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\"\n        }\n\n# çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ\nstatus_result = check_timer_status()\nprint(json.dumps(status_result, ensure_ascii=False))"
      }
    },
    {
      "id": "timer_output",
      "type": "TextOutput",
      "position": { "x": 700, "y": 200 },
      "data": {
        "output_name": "timer_result",
        "output_description": "ã‚¿ã‚¤ãƒãƒ¼å®Ÿè¡Œçµæœã¨Yes-Mané¢¨ã®å¿œç­”"
      }
    }
  ],
  "edges": [
    {
      "id": "timer_edge_1",
      "source": "timer_input",
      "sourceHandle": "output",
      "target": "duration_parser",
      "targetHandle": "input"
    },
    {
      "id": "timer_edge_2",
      "source": "duration_parser",
      "sourceHandle": "output",
      "target": "timer_executor",
      "targetHandle": "input"
    },
    {
      "id": "timer_edge_3",
      "source": "timer_executor",
      "sourceHandle": "output",
      "target": "timer_output",
      "targetHandle": "input"
    },
    {
      "id": "timer_edge_4",
      "source": "timer_status",
      "sourceHandle": "output",
      "target": "timer_output",
      "targetHandle": "status_input"
    }
  ],
  "settings": {
    "tool_name": "timer",
    "tool_description": "Yes-Manç”¨ã‚¿ã‚¤ãƒãƒ¼ãƒ„ãƒ¼ãƒ«",
    "tool_category": "utility",
    "features": {
      "multiple_timers": true,
      "flexible_input": true,
      "background_execution": true,
      "notification_support": true
    },
    "limits": {
      "min_duration": 1,
      "max_duration": 3600,
      "max_concurrent_timers": 10
    },
    "supported_formats": [
      "ç§’æ•°ã®ã¿ï¼ˆä¾‹: 30ï¼‰",
      "ç§’æŒ‡å®šï¼ˆä¾‹: 30ç§’, 30sï¼‰",
      "åˆ†æŒ‡å®šï¼ˆä¾‹: 5åˆ†, 5min, 5mï¼‰",
      "æ™‚é–“æŒ‡å®šï¼ˆä¾‹: 1æ™‚é–“, 1hour, 1hï¼‰",
      "è¤‡åˆæŒ‡å®šï¼ˆä¾‹: 3åˆ†30ç§’, 1æ™‚é–“30åˆ†ï¼‰",
      "MM:SSå½¢å¼ï¼ˆä¾‹: 5:30ï¼‰",
      "HH:MM:SSå½¢å¼ï¼ˆä¾‹: 1:30:45ï¼‰"
    ]
  },
  "examples": [
    {
      "input": "30",
      "expected_output": "ã¯ã„ï¼30ç§’ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸï¼æ™‚é–“ã«ãªã£ãŸã‚‰ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ï¼",
      "description": "ç§’æ•°ã®ã¿æŒ‡å®š"
    },
    {
      "input": "5åˆ†",
      "expected_output": "ã‚‚ã¡ã‚ã‚“ã§ã™ï¼5åˆ†ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼",
      "description": "åˆ†å˜ä½æŒ‡å®š"
    },
    {
      "input": "3åˆ†30ç§’",
      "expected_output": "ã‚¿ã‚¤ãƒãƒ¼è¨­å®šå®Œäº†ã§ã™ï¼3åˆ†30ç§’å¾Œã«ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã­ï¼",
      "description": "è¤‡åˆæ™‚é–“æŒ‡å®š"
    },
    {
      "input": "10:30",
      "expected_output": "ã¯ã„ã€10åˆ†30ç§’ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¾ã—ãŸï¼",
      "description": "MM:SSå½¢å¼"
    }
  ],
  "metadata": {
    "created_at": "2025-09-08T00:00:00Z",
    "updated_at": "2025-09-08T00:00:00Z",
    "version": "1.0.0",
    "compatibility": {
      "langflow_version": ">=1.0.0",
      "python_version": ">=3.8"
    },
    "dependencies": {
      "threading": "builtin",
      "time": "builtin",
      "datetime": "builtin",
      "re": "builtin",
      "json": "builtin"
    },
    "notifications": {
      "completion_methods": [
        "éŸ³å£°é€šçŸ¥ï¼ˆTTSï¼‰",
        "UIé€šçŸ¥",
        "ãƒ­ã‚°å‡ºåŠ›"
      ],
      "integration_points": [
        "IPCé€šä¿¡",
        "WebSocket",
        "éŸ³å£°ãƒ¬ã‚¤ãƒ¤ãƒ¼é€£æº"
      ]
    }
  }
}